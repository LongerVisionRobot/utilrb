--- fastthread-0.6.2/ext/fastthread/fastthread.c	2007-01-25 12:09:54.956708000 +0100
+++ fastthread-0.6.2.new/ext/fastthread/fastthread.c	2007-01-25 11:49:49.151455000 +0100
@@ -737,6 +737,61 @@ rb_queue_marshal_load(self, data)
 
 static VALUE rb_queue_marshal_dump _((VALUE));
 
+
+/* call-seq:
+ *  Queue#get(non_block = false) => array
+ *
+ * Returns an array containing all elements currently in the queue. After a call
+ * to #get, the queue is empty. If non_block is false, the call will block until
+ * there is something in it. Otherwise, if the queue is empty, it returns an empty
+ * array.
+ */
+static VALUE
+rb_queue_get(argc, argv, self)
+  int argc;
+  VALUE *argv;
+  VALUE self;
+{
+  Queue *queue;
+  int should_block;
+  VALUE result;
+  Data_Get_Struct(self, Queue, queue);
+
+  if ( argc == 0 ) {
+    should_block = 1;
+  } else if ( argc == 1 ) {
+    should_block = !RTEST(argv[0]);
+  } else {
+    rb_raise(rb_eArgError, "wrong number of arguments (%d for 1)", argc);
+  }
+
+  lock_mutex(&queue->mutex);
+  if ( !queue->values.entries ) {
+    /* NOTE: locking is not needed to check if the queue is empty
+       since AFAIK C extensions are never preempted. I do as in #pop
+       where it is done.
+    */
+    if ( !should_block ) {
+      unlock_mutex(&queue->mutex);
+      return rb_ary_new();
+    }
+    while (!queue->values.entries) {
+      wait_condvar(&queue->value_available, &queue->mutex);
+    }
+  }
+
+  result = rb_ary_new();
+  while ( queue->values.entries ) {
+    rb_ary_push(result, shift_list(&queue->values));
+  }
+  if ( queue->capacity ) {
+    signal_condvar(&queue->space_available);
+  }
+  unlock_mutex(&queue->mutex);
+
+  return result;
+}
+
 static VALUE
 rb_queue_marshal_dump(self)
   VALUE self;
@@ -991,6 +1046,7 @@ static VALUE setup_classes(unused)
   rb_define_method(rb_cQueue, "num_waiting", rb_queue_num_waiting, 0);
   rb_define_method(rb_cQueue, "pop", rb_queue_pop, -1);
   rb_define_method(rb_cQueue, "push", rb_queue_push, 1);
+  rb_define_method(rb_cQueue, "get", rb_queue_get, -1);
   rb_alias(rb_cQueue, rb_intern("<<"), rb_intern("push"));
   rb_alias(rb_cQueue, rb_intern("deq"), rb_intern("pop"));
   rb_alias(rb_cQueue, rb_intern("shift"), rb_intern("pop"));
